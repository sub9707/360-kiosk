package com.howdoyoudo.camera_360

import android.annotation.SuppressLint
import android.content.Context
import android.os.Build
import android.util.Log
import android.util.Size
import android.os.Handler
import android.os.Looper
import android.os.Environment

import androidx.camera.core.CameraSelector
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.video.FileOutputOptions
import androidx.camera.video.Quality
import androidx.camera.video.QualitySelector
import androidx.camera.video.Recorder
import androidx.camera.video.Recording
import androidx.camera.video.VideoCapture
import androidx.camera.video.VideoRecordEvent
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner

import androidx.camera.core.resolutionselector.AspectRatioStrategy
import androidx.camera.core.resolutionselector.ResolutionSelector
import androidx.camera.core.resolutionselector.ResolutionStrategy

import java.io.File
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import org.json.JSONObject

class CameraXManager(private val context: Context, private val lifecycleOwner: LifecycleOwner) {

    private val TAG = "CameraXManager"
    private var cameraExecutor: ExecutorService = Executors.newSingleThreadExecutor()
    private var videoCapture: VideoCapture<Recorder>? = null
    private var recording: Recording? = null
    private var preview: Preview? = null
    private var cameraProvider: ProcessCameraProvider? = null

    // üîß Ïπ¥Î©îÎùº ÏÉÅÌÉú Í¥ÄÎ¶¨ Î≥ÄÏàò Í∞ïÌôî
    private var isCameraInitialized = false
    private var isRecordingInProgress = false
    private var isPreviewActive = false
    private var initializationInProgress = false

    // üé¨ 20Ï¥à ÌÉÄÏù¥Î®∏ Í¥ÄÎ†® Î≥ÄÏàò
    private var recordingTimer: Handler? = null
    private var recordingRunnable: Runnable? = null
    private val RECORDING_DURATION_MS = 20 * 1000L // 20Ï¥à

    // üìÅ Scoped Storage Ìò∏Ìôò Ï†ÄÏû• Í≤ΩÎ°ú
    private val VIDEO_SAVE_DIR = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        // Android 10+ : Ïï± Ï†ÑÏö© Ïô∏Î∂Ä Ï†ÄÏû•ÏÜå ÏÇ¨Ïö© (Í∂åÌïú Î∂àÌïÑÏöî)
        File(context.getExternalFilesDir(Environment.DIRECTORY_MOVIES) ?: context.filesDir, "ElectronCameraApp")
    } else {
        // Android 9 Ïù¥Ìïò : Í∏∞Ï°¥ Î∞©Ïãù
        File(Environment.getExternalStorageDirectory(), "Movies/ElectronCameraApp")
    }

    // ÎπÑÎîîÏò§ Ï†ÄÏû• ÏôÑÎ£å ÏΩúÎ∞±
    private var onVideoSavedListener: ((String) -> Unit)? = null

    fun setOnVideoSavedListener(listener: (String) -> Unit) {
        this.onVideoSavedListener = listener
    }

    init {
        // Ï†ÄÏû• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        if (!VIDEO_SAVE_DIR.exists()) {
            val created = VIDEO_SAVE_DIR.mkdirs()
            Log.d(TAG, "üìÅ Video directory created: $created at ${VIDEO_SAVE_DIR.absolutePath}")
        } else {
            Log.d(TAG, "üìÅ Video directory exists: ${VIDEO_SAVE_DIR.absolutePath}")
        }
    }

    @SuppressLint("RestrictedApi")
    fun startCameraPreview(previewView: PreviewView) {
        // üîß Ï§ëÎ≥µ Ï¥àÍ∏∞Ìôî Î∞©ÏßÄ Í∞ïÌôî
        if (initializationInProgress) {
            Log.d(TAG, "üì∑ Camera initialization already in progress, skipping")
            return
        }

        if (isCameraInitialized && isPreviewActive) {
            Log.d(TAG, "üì∑ Camera already initialized and preview active, skipping")
            return
        }

        initializationInProgress = true
        Log.d(TAG, "üì∑ Starting camera initialization...")

        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)

        cameraProviderFuture.addListener({
            try {
                // üîß ÏïàÏ†ÑÌïú Ïπ¥Î©îÎùº Ï†ïÎ¶¨
                safeCleanupCamera()

                cameraProvider = cameraProviderFuture.get()

                // üîß Î™®Îì† Í∏∞Ï°¥ use case Î∞îÏù∏Îî© Ìï¥Ï†ú
                cameraProvider?.unbindAll()

                // Ïû†Ïãú ÎåÄÍ∏∞ (Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ ÏãúÍ∞Ñ ÌôïÎ≥¥)
                Thread.sleep(100)

                // Preview ÏÉùÏÑ±
                preview = Preview.Builder()
                    .setResolutionSelector(
                        ResolutionSelector.Builder()
                            .setAspectRatioStrategy(AspectRatioStrategy.RATIO_16_9_FALLBACK_AUTO_STRATEGY)
                            .setResolutionStrategy(ResolutionStrategy(Size(1280, 720), ResolutionStrategy.FALLBACK_RULE_NONE))
                            .build()
                    )
                    .build()

                // Recorder (for video capture)
                val recorder = Recorder.Builder()
                    .setQualitySelector(QualitySelector.from(Quality.FHD))
                    .build()
                videoCapture = VideoCapture.withOutput(recorder)

                // üîß Preview surface provider ÏÑ§Ï†ï (Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑú)
                Handler(Looper.getMainLooper()).post {
                    try {
                        preview?.setSurfaceProvider(previewView.surfaceProvider)

                        // Ïπ¥Î©îÎùº Î∞îÏù∏Îî©
                        cameraProvider?.bindToLifecycle(
                            lifecycleOwner,
                            CameraSelector.DEFAULT_BACK_CAMERA,
                            preview,
                            videoCapture
                        )

                        isCameraInitialized = true
                        isPreviewActive = true
                        initializationInProgress = false

                        Log.d(TAG, "‚úÖ Camera preview started successfully")

                    } catch (bindException: Exception) {
                        Log.e(TAG, "‚ùå Camera binding failed", bindException)
                        initializationInProgress = false
                        handleCameraError(bindException)
                    }
                }

            } catch (exc: Exception) {
                Log.e(TAG, "‚ùå Camera provider failed", exc)
                initializationInProgress = false
                handleCameraError(exc)
            }
        }, ContextCompat.getMainExecutor(context))
    }

    // üîß Ïπ¥Î©îÎùº Ïò§Î•ò Ï≤òÎ¶¨
    private fun handleCameraError(exception: Exception) {
        Log.e(TAG, "üîß Handling camera error: ${exception.message}")
        safeCleanupCamera()

        // 3Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ
        Handler(Looper.getMainLooper()).postDelayed({
            Log.d(TAG, "üîÑ Retrying camera initialization after error...")
            initializationInProgress = false
            // restartCamera Î©îÏÑúÎìúÎäî Ïô∏Î∂ÄÏóêÏÑú Ìò∏Ï∂úÌïòÎèÑÎ°ù Ìï®
        }, 3000)
    }

    @SuppressLint("MissingPermission")
    fun startRecording() {
        if (!isCameraInitialized) {
            Log.e(TAG, "‚ùå Camera not initialized. Cannot start recording.")
            return
        }

        if (videoCapture == null) {
            Log.e(TAG, "‚ùå VideoCapture is not initialized.")
            return
        }

        if (isRecordingInProgress) {
            Log.w(TAG, "‚ö†Ô∏è Recording already in progress. Ignoring start request.")
            return
        }

        Log.d(TAG, "üé¨ Starting recording...")

        // üîß ÏïàÏ†ÑÌïú Í∏∞Ï°¥ ÎÖπÌôî Ï†ïÎ¶¨
        safeCleanupRecording()

        // üé¨ Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏Í∞Ä ÏûàÏúºÎ©¥ Ï∑®ÏÜå
        stopRecordingTimer()

        // üìÅ ÏßÅÏ†ë ÌååÏùº ÏãúÏä§ÌÖúÏóê Ï†ÄÏû•Ìï† ÌååÏùº ÏÉùÏÑ±
        val name = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(System.currentTimeMillis())
        val fileName = "VIDEO_${name}.mp4"
        val videoFile = File(VIDEO_SAVE_DIR, fileName)

        Log.d(TAG, "üé¨ Recording will be saved to: ${videoFile.absolutePath}")

        // üìÅ FileOutputOptions ÏÇ¨Ïö©
        val fileOutputOptions = FileOutputOptions.Builder(videoFile).build()

        try {
            recording = videoCapture?.output?.prepareRecording(
                context,
                fileOutputOptions
            )
                ?.withAudioEnabled()
                ?.start(ContextCompat.getMainExecutor(context)) { recordEvent: VideoRecordEvent ->
                    handleRecordingEvent(recordEvent, fileName, videoFile)
                }

            if (recording != null) {
                Log.d(TAG, "üé¨ Recording start initiated successfully")
            } else {
                Log.e(TAG, "‚ùå Failed to start recording - recording is null")
                isRecordingInProgress = false
            }

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Exception during recording start: ${e.message}", e)
            isRecordingInProgress = false
            safeCleanupRecording()
        }
    }

    // üîß ÎÖπÌôî Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ Î∂ÑÎ¶¨
    private fun handleRecordingEvent(recordEvent: VideoRecordEvent, fileName: String, videoFile: File) {
        when (recordEvent) {
            is VideoRecordEvent.Start -> {
                Log.d(TAG, "üé¨ Recording started - 20Ï¥à ÌÉÄÏù¥Î®∏ ÏãúÏûë")
                isRecordingInProgress = true
                IPCService.INSTANCE?.sendMessageToElectron("camera-recording-status", JSONObject().apply {
                    put("isRecording", true)
                    put("fileName", fileName)
                })

                // üé¨ 20Ï¥à ÌõÑ ÏûêÎèô Ï§ëÏßÄ ÌÉÄÏù¥Î®∏ ÏãúÏûë
                startRecordingTimer()
            }
            is VideoRecordEvent.Finalize -> {
                Log.d(TAG, "üé¨ Recording finalized")
                isRecordingInProgress = false
                stopRecordingTimer()

                if (!recordEvent.hasError()) {
                    handleSuccessfulRecording(videoFile, fileName)
                } else {
                    // üîß VideoRecordEvent.FinalizeÏùò Ïò¨Î∞îÎ•∏ ÏóêÎü¨ Ï≤òÎ¶¨
                    val errorCode = recordEvent.error
                    val errorCause = recordEvent.cause
                    handleFailedRecording(errorCode, errorCause, fileName)
                }

                IPCService.INSTANCE?.sendMessageToElectron("camera-recording-status", JSONObject().apply {
                    put("isRecording", false)
                })
            }
            is VideoRecordEvent.Status -> {
                // üîß ÏÉÅÌÉú Î°úÍ∑∏ Ï§ÑÏù¥Í∏∞
                val stats = recordEvent.recordingStats
                if (stats.recordedDurationNanos > 0) {
                    val durationSeconds = stats.recordedDurationNanos / 1_000_000_000.0
                    if (durationSeconds.toInt() % 3 == 0) { // 3Ï¥àÎßàÎã§Îßå Î°úÍ∑∏
                        Log.d(TAG, "üé¨ Recording: ${String.format("%.1f", durationSeconds)}Ï¥à")
                    }
                }
            }
        }
    }

    // üîß ÏÑ±Í≥µÏ†ÅÏù∏ ÎÖπÌôî Ï≤òÎ¶¨
    private fun handleSuccessfulRecording(videoFile: File, fileName: String) {
        Log.d(TAG, "‚úÖ Video saved successfully!")
        Log.d(TAG, "üìÅ File: ${videoFile.absolutePath} (${videoFile.length()} bytes)")

        if (videoFile.exists() && videoFile.length() > 0) {
            IPCService.INSTANCE?.sendMessageToElectron("video-saved", JSONObject().apply {
                put("fileName", fileName)
                put("fileSize", videoFile.length())
            })
            onVideoSavedListener?.invoke(fileName)

            // üîß ÎîîÎ†âÌÜ†Î¶¨ Î°úÍ∑∏ Ï§ÑÏù¥Í∏∞
            VIDEO_SAVE_DIR.listFiles()?.let { files ->
                Log.d(TAG, "üìÇ Directory: ${files.size} files")
            }
        } else {
            Log.e(TAG, "‚ùå Saved file invalid!")
            IPCService.INSTANCE?.sendMessageToElectron("video-saved", JSONObject().apply {
                put("success", false)
                put("error", "Saved file does not exist or is empty")
            })
        }
    }

    // üîß Ïã§Ìå®Ìïú ÎÖπÌôî Ï≤òÎ¶¨ (Í∞ÑÏÜåÌôî)
    private fun handleFailedRecording(errorCode: Int, errorCause: Throwable?, fileName: String) {
        val errorMessage = "ÎÖπÌôî Ïã§Ìå® (Ïò§Î•ò ÏΩîÎìú: $errorCode)"

        val fullErrorMessage = if (errorCause != null) {
            "$errorMessage - ${errorCause.message}"
        } else {
            errorMessage
        }

        Log.e(TAG, "‚ùå Recording failed: $fullErrorMessage")
        IPCService.INSTANCE?.sendMessageToElectron("video-saved", JSONObject().apply {
            put("success", false)
            put("error", fullErrorMessage)
            put("errorCode", errorCode)
            put("fileName", fileName)
        })
    }

    /**
     * üé¨ 20Ï¥à ÎÖπÌôî ÌÉÄÏù¥Î®∏ ÏãúÏûë
     */
    private fun startRecordingTimer() {
        recordingTimer = Handler(Looper.getMainLooper())
        recordingRunnable = Runnable {
            Log.d(TAG, "üé¨ 20Ï¥à ÌÉÄÏù¥Î®∏ ÏôÑÎ£å - ÏûêÎèôÏúºÎ°ú ÎÖπÌôî Ï§ëÏßÄ")
            stopRecording()
        }
        recordingTimer?.postDelayed(recordingRunnable!!, RECORDING_DURATION_MS)
    }

    /**
     * üé¨ ÎÖπÌôî ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
     */
    private fun stopRecordingTimer() {
        recordingRunnable?.let { runnable ->
            recordingTimer?.removeCallbacks(runnable)
        }
        recordingTimer = null
        recordingRunnable = null
    }

    /**
     * ÎπÑÎîîÏò§ ÎÖπÌôîÎ•º Ï§ëÏßÄÌï©ÎãàÎã§.
     */
    fun stopRecording() {
        Log.d(TAG, "üé¨ Stop recording called")
        stopRecordingTimer()

        if (recording != null && isRecordingInProgress) {
            try {
                recording?.stop()
                Log.d(TAG, "üé¨ Recording stopped successfully")
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error stopping recording: ${e.message}")
            }
            recording = null
            isRecordingInProgress = false
        } else {
            Log.d(TAG, "üé¨ No active recording to stop")
        }
    }

    /**
     * üîß ÏïàÏ†ÑÌïú ÎÖπÌôî Í¥ÄÎ†® Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
     */
    private fun safeCleanupRecording() {
        try {
            stopRecordingTimer()

            if (recording != null) {
                try {
                    recording?.stop()
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Error stopping recording during cleanup: ${e.message}")
                }
                recording = null
            }

            isRecordingInProgress = false
            Log.d(TAG, "üîß Recording cleanup completed")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error during recording cleanup: ${e.message}")
        }
    }

    /**
     * üîß ÏïàÏ†ÑÌïú Ïπ¥Î©îÎùº Í¥ÄÎ†® Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
     */
    private fun safeCleanupCamera() {
        try {
            // ÎÖπÌôî Î®ºÏ†Ä Ï†ïÎ¶¨
            safeCleanupRecording()

            // Preview surface provider Ï†ïÎ¶¨ (Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑú)
            Handler(Looper.getMainLooper()).post {
                try {
                    preview?.setSurfaceProvider(null)
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Error clearing surface provider: ${e.message}")
                }
            }

            // Ïπ¥Î©îÎùº Î∞îÏù∏Îî© Ìï¥Ï†ú
            try {
                cameraProvider?.unbindAll()
            } catch (e: Exception) {
                Log.w(TAG, "‚ö†Ô∏è Error unbinding camera: ${e.message}")
            }

            // Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
            preview = null
            videoCapture = null
            isPreviewActive = false

            Log.d(TAG, "üîß Camera cleanup completed")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error during camera cleanup: ${e.message}")
        }
    }

    /**
     * CameraX Í¥ÄÎ†® Î¶¨ÏÜåÏä§Î•º Ï†ïÎ¶¨ÌïòÍ≥† Ïä§Î†àÎìú ÌíÄÏùÑ Ï¢ÖÎ£åÌï©ÎãàÎã§.
     */
    fun shutdown() {
        Log.d(TAG, "üõë CameraXManager shutdown initiated")

        // Ï¥àÍ∏∞Ìôî ÏÉÅÌÉú Î¶¨ÏÖã
        initializationInProgress = false
        isCameraInitialized = false

        // Ïπ¥Î©îÎùº Ï†ïÎ¶¨
        safeCleanupCamera()

        // ExecutorService Ï¢ÖÎ£å
        try {
            cameraExecutor.shutdown()
            if (!cameraExecutor.awaitTermination(2, java.util.concurrent.TimeUnit.SECONDS)) {
                cameraExecutor.shutdownNow()
            }
            Log.d(TAG, "üõë CameraExecutor shutdown complete")
        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error shutting down camera executor: ${e.message}")
            cameraExecutor.shutdownNow()
        }

        Log.d(TAG, "‚úÖ CameraXManager shutdown complete")
    }

    /**
     * üîß Ïπ¥Î©îÎùº Ïû¨ÏãúÏûë (Î¨∏Ï†ú Î∞úÏÉù Ïãú Î≥µÍµ¨Ïö©)
     */
    fun restartCamera(previewView: PreviewView) {
        Log.d(TAG, "üîÑ Restarting camera...")

        // ÏÉÅÌÉú Î¶¨ÏÖã
        initializationInProgress = false
        isCameraInitialized = false
        isPreviewActive = false

        // Ï†ïÎ¶¨ ÌõÑ Ïû¨ÏãúÏûë
        safeCleanupCamera()

        // 1Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÏûë
        Handler(Looper.getMainLooper()).postDelayed({
            startCameraPreview(previewView)
        }, 1000)
    }

    /**
     * üîß Ïπ¥Î©îÎùº ÏÉÅÌÉú ÌôïÏù∏
     */
    fun getCameraStatus(): String {
        return "Initialized: $isCameraInitialized, PreviewActive: $isPreviewActive, Recording: $isRecordingInProgress, InitInProgress: $initializationInProgress"
    }
}