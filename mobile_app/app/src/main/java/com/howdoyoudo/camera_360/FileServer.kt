package com.howdoyoudo.camera_360

import android.content.Context
import android.os.Build
import android.util.Log
import android.os.Environment
import fi.iki.elonen.NanoHTTPD
import java.io.FileInputStream
import java.io.FileNotFoundException
import java.io.IOException
import java.io.File

class FileServer(private val context: Context, private val port: Int) : NanoHTTPD(port) {

    private val TAG = "FileServer"

    // üîß CameraXManagerÏôÄ ÎèôÏùºÌïú Í≤ΩÎ°ú ÏÇ¨Ïö©
    private val BASE_VIDEO_PATH = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        // Android 10+ : Ïï± Ï†ÑÏö© Ïô∏Î∂Ä Ï†ÄÏû•ÏÜå ÏÇ¨Ïö©
        File(context.getExternalFilesDir(Environment.DIRECTORY_MOVIES) ?: context.filesDir, "ElectronCameraApp").absolutePath
    } else {
        // Android 9 Ïù¥Ìïò : Í∏∞Ï°¥ Î∞©Ïãù
        File(Environment.getExternalStorageDirectory(), "Movies/ElectronCameraApp").absolutePath
    }

    init {
        Log.d(TAG, "üîß FileServer initialized with base path: $BASE_VIDEO_PATH")
        checkDirectoryAndPermissions()
    }

    /**
     * üîç ÎîîÎ†âÌÜ†Î¶¨ Î∞è Í∂åÌïú ÏÉÅÌÉú ÌôïÏù∏
     */
    private fun checkDirectoryAndPermissions() {
        val baseDir = File(BASE_VIDEO_PATH)

        Log.d(TAG, "üìÇ Directory check:")
        Log.d(TAG, "  Path: ${baseDir.absolutePath}")
        Log.d(TAG, "  Exists: ${baseDir.exists()}")
        Log.d(TAG, "  Is Directory: ${baseDir.isDirectory}")
        Log.d(TAG, "  Can Read: ${baseDir.canRead()}")
        Log.d(TAG, "  Can Write: ${baseDir.canWrite()}")

        // External storage ÏÉÅÌÉú ÌôïÏù∏
        val storageState = Environment.getExternalStorageState()
        Log.d(TAG, "üì± External Storage State: $storageState")
        Log.d(TAG, "üì± External Storage Available: ${Environment.MEDIA_MOUNTED == storageState}")

        // ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ± ÏãúÎèÑ
        if (!baseDir.exists()) {
            Log.w(TAG, "‚ö†Ô∏è Directory does not exist, attempting to create...")
            val created = baseDir.mkdirs()
            Log.d(TAG, "üìÅ Directory creation result: $created")
        }

        // ÌååÏùº Î™©Î°ù ÌôïÏù∏
        try {
            val files = baseDir.listFiles()
            if (files != null) {
                Log.d(TAG, "üìÇ Found ${files.size} files in directory:")
                files.forEach { file ->
                    Log.d(TAG, "  üìÑ ${file.name} (${file.length()} bytes) - ${if (file.canRead()) "readable" else "not readable"}")
                }
            } else {
                Log.w(TAG, "‚ö†Ô∏è Cannot list files in directory (permission issue?)")
            }
        } catch (e: SecurityException) {
            Log.e(TAG, "‚ùå Security exception when listing files: ${e.message}")
        }
    }

    override fun serve(session: IHTTPSession): Response {
        val uri = session.uri
        val method = session.method
        val remoteIP = session.headers["http-client-ip"] ?: session.headers["remote-addr"] ?: "unknown"

        Log.d(TAG, "üåê HTTP $method Request: $uri from $remoteIP")

        // üîç Î£®Ìä∏ Í≤ΩÎ°ú ÏöîÏ≤≠ Ïãú ÏÑúÎ≤Ñ ÏÉÅÌÉú Î∞è ÌååÏùº Î™©Î°ù Î∞òÌôò
        if (uri == "/" || uri == "/status") {
            return getServerStatus()
        }

        // üîç ÌååÏùº Î™©Î°ù Ï°∞Ìöå
        if (uri == "/list" || uri.startsWith("/list/")) {
            return getFileList()
        }

        // üîç Ïã§ÏãúÍ∞Ñ ÎîîÎ†âÌÜ†Î¶¨ Ï≤¥ÌÅ¨
        if (uri == "/check") {
            checkDirectoryAndPermissions()
            return newFixedLengthResponse(Response.Status.OK, MIME_PLAINTEXT, "Directory check completed. See logcat for details.")
        }

        // ÎπÑÎîîÏò§ ÌååÏùº Îã§Ïö¥Î°úÎìú ÏöîÏ≤≠ Ï≤òÎ¶¨
        if (uri.startsWith("/video/")) {
            val filename = uri.substring("/video/".length)
            Log.d(TAG, "üé¨ Video file requested: '$filename'")

            // ÌååÏùºÎ™Ö Í≤ÄÏ¶ù
            if (filename.isEmpty() || filename.contains("..") || filename.contains("/")) {
                Log.w(TAG, "‚ùå Invalid filename: '$filename'")
                return newFixedLengthResponse(Response.Status.BAD_REQUEST, MIME_PLAINTEXT, "Error: Invalid filename")
            }

            val videoFile = File(BASE_VIDEO_PATH, filename)
            Log.d(TAG, "üîç Looking for file: ${videoFile.absolutePath}")

            // üîç ÌååÏùº ÏÉÅÌÉú ÏÉÅÏÑ∏ ÌôïÏù∏
            Log.d(TAG, "üìä File status:")
            Log.d(TAG, "  Exists: ${videoFile.exists()}")
            Log.d(TAG, "  Is File: ${videoFile.isFile}")
            Log.d(TAG, "  Can Read: ${videoFile.canRead()}")
            Log.d(TAG, "  Size: ${if (videoFile.exists()) videoFile.length() else "N/A"} bytes")
            Log.d(TAG, "  Parent Dir: ${videoFile.parentFile?.absolutePath}")
            Log.d(TAG, "  Parent Exists: ${videoFile.parentFile?.exists()}")

            if (videoFile.exists() && videoFile.isFile && videoFile.canRead()) {
                try {
                    val mimeType = getMimeType(filename)
                    val fileSize = videoFile.length()

                    if (fileSize == 0L) {
                        Log.w(TAG, "‚ö†Ô∏è File exists but is empty: ${videoFile.absolutePath}")
                        return newFixedLengthResponse(Response.Status.NO_CONTENT, MIME_PLAINTEXT, "Error: File is empty")
                    }

                    val fis = FileInputStream(videoFile)

                    Log.d(TAG, "‚úÖ Serving file: ${videoFile.absolutePath}")
                    Log.d(TAG, "üìä File size: $fileSize bytes, MIME: $mimeType")

                    val response = newChunkedResponse(Response.Status.OK, mimeType, fis)

                    // CORS Ìó§Îçî Ï∂îÍ∞Ä
                    response.addHeader("Access-Control-Allow-Origin", "*")
                    response.addHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    response.addHeader("Access-Control-Allow-Headers", "Content-Type")
                    response.addHeader("Content-Disposition", "attachment; filename=\"$filename\"")

                    return response
                } catch (e: FileNotFoundException) {
                    Log.e(TAG, "‚ùå File not found during serving: ${e.message}")
                    return newFixedLengthResponse(Response.Status.NOT_FOUND, MIME_PLAINTEXT, "Error: File not found during read - ${e.message}")
                } catch (e: IOException) {
                    Log.e(TAG, "‚ùå IO Error during serving: ${e.message}")
                    return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, MIME_PLAINTEXT, "Error: Internal server error - ${e.message}")
                } catch (e: SecurityException) {
                    Log.e(TAG, "‚ùå Security Error during serving: ${e.message}")
                    return newFixedLengthResponse(Response.Status.FORBIDDEN, MIME_PLAINTEXT, "Error: Permission denied - ${e.message}")
                }
            } else {
                Log.w(TAG, "‚ùå File access failed: ${videoFile.absolutePath}")
                Log.w(TAG, "  Exists: ${videoFile.exists()}")
                Log.w(TAG, "  Is File: ${videoFile.isFile}")
                Log.w(TAG, "  Can Read: ${videoFile.canRead()}")

                // üîç ÎîîÎ†âÌÜ†Î¶¨ ÎÇ¥Ïö© Ïû¨ÌôïÏù∏
                val parentDir = File(BASE_VIDEO_PATH)
                if (parentDir.exists() && parentDir.isDirectory) {
                    try {
                        val files = parentDir.listFiles()
                        Log.d(TAG, "üìÅ Directory contents (${files?.size ?: 0} files):")
                        files?.forEach { file ->
                            Log.d(TAG, "  üìÑ ${file.name} (${file.length()} bytes) - readable: ${file.canRead()}")
                        }
                    } catch (e: SecurityException) {
                        Log.e(TAG, "‚ùå Cannot list directory contents: ${e.message}")
                    }
                } else {
                    Log.w(TAG, "‚ùå Base directory issue: exists=${parentDir.exists()}, isDir=${parentDir.isDirectory}")
                }

                return newFixedLengthResponse(
                    Response.Status.NOT_FOUND,
                    MIME_PLAINTEXT,
                    "Error: File '$filename' not accessible.\nExists: ${videoFile.exists()}\nReadable: ${videoFile.canRead()}\nDirectory: $BASE_VIDEO_PATH"
                )
            }
        }

        // OPTIONS ÏöîÏ≤≠ Ï≤òÎ¶¨ (CORS preflight)
        if (method == Method.OPTIONS) {
            val response = newFixedLengthResponse(Response.Status.OK, MIME_PLAINTEXT, "")
            response.addHeader("Access-Control-Allow-Origin", "*")
            response.addHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
            response.addHeader("Access-Control-Allow-Headers", "Content-Type")
            return response
        }

        Log.w(TAG, "‚ùå Unknown request: $method $uri")
        return newFixedLengthResponse(Response.Status.NOT_FOUND, MIME_PLAINTEXT, "The requested URL was not found on this server.")
    }

    /**
     * üîç ÏÑúÎ≤Ñ ÏÉÅÌÉú Î∞è Í∏∞Î≥∏ Ï†ïÎ≥¥ Î∞òÌôò
     */
    private fun getServerStatus(): Response {
        val baseDir = File(BASE_VIDEO_PATH)
        val status = StringBuilder()

        status.append("üé¨ FileServer Status\n")
        status.append("===================\n")
        status.append("Port: $port\n")
        status.append("Base Path: $BASE_VIDEO_PATH\n")
        status.append("Directory Exists: ${baseDir.exists()}\n")
        status.append("Directory Readable: ${baseDir.canRead()}\n")
        status.append("External Storage State: ${Environment.getExternalStorageState()}\n")
        status.append("Storage Available: ${Environment.MEDIA_MOUNTED == Environment.getExternalStorageState()}\n\n")

        if (baseDir.exists()) {
            try {
                val files = baseDir.listFiles()?.filter { it.name.endsWith(".mp4") } ?: emptyList()
                status.append("Video Files: ${files.size}\n\n")

                files.forEach { file ->
                    status.append("üìπ ${file.name}\n")
                    status.append("   Size: ${file.length()} bytes\n")
                    status.append("   Readable: ${file.canRead()}\n")
                    status.append("   URL: http://[SERVER_IP]:$port/video/${file.name}\n\n")
                }
            } catch (e: SecurityException) {
                status.append("‚ùå Permission denied to list files: ${e.message}\n")
            }
        } else {
            status.append("‚ùå Base directory does not exist!\n")
        }

        val response = newFixedLengthResponse(Response.Status.OK, MIME_PLAINTEXT, status.toString())
        response.addHeader("Access-Control-Allow-Origin", "*")
        return response
    }

    /**
     * üîç ÌååÏùº Î™©Î°ù JSON ÌòïÌÉúÎ°ú Î∞òÌôò
     */
    private fun getFileList(): Response {
        val baseDir = File(BASE_VIDEO_PATH)
        val fileList = StringBuilder()

        fileList.append("{\n")
        fileList.append("  \"status\": \"ok\",\n")
        fileList.append("  \"basePath\": \"$BASE_VIDEO_PATH\",\n")
        fileList.append("  \"directoryExists\": ${baseDir.exists()},\n")
        fileList.append("  \"files\": [\n")

        if (baseDir.exists()) {
            try {
                val files = baseDir.listFiles()?.filter { it.name.endsWith(".mp4") && it.canRead() } ?: emptyList()
                files.forEachIndexed { index, file ->
                    fileList.append("    {\n")
                    fileList.append("      \"name\": \"${file.name}\",\n")
                    fileList.append("      \"size\": ${file.length()},\n")
                    fileList.append("      \"readable\": ${file.canRead()},\n")
                    fileList.append("      \"url\": \"/video/${file.name}\"\n")
                    fileList.append("    }")
                    if (index < files.size - 1) fileList.append(",")
                    fileList.append("\n")
                }
            } catch (e: SecurityException) {
                fileList.append("    {\"error\": \"Permission denied: ${e.message}\"}\n")
            }
        }

        fileList.append("  ],\n")
        fileList.append("  \"timestamp\": ${System.currentTimeMillis()}\n")
        fileList.append("}")

        val response = newFixedLengthResponse(Response.Status.OK, "application/json", fileList.toString())
        response.addHeader("Access-Control-Allow-Origin", "*")
        return response
    }

    private fun getMimeType(filename: String): String {
        return when {
            filename.endsWith(".mp4") -> "video/mp4"
            filename.endsWith(".png") -> "image/png"
            filename.endsWith(".jpg") || filename.endsWith(".jpeg") -> "image/jpeg"
            else -> MIME_PLAINTEXT
        }
    }

    fun startServer() {
        try {
            start(SOCKET_READ_TIMEOUT, false)
            Log.d(TAG, "‚úÖ File server started on port $port")
            Log.d(TAG, "üåê Server URLs:")
            Log.d(TAG, "  Status: http://[DEVICE_IP]:$port/status")
            Log.d(TAG, "  File List: http://[DEVICE_IP]:$port/list")
            Log.d(TAG, "  Directory Check: http://[DEVICE_IP]:$port/check")

            // ÏãúÏûë Ïãú ÎîîÎ†âÌÜ†Î¶¨ ÏÉÅÌÉú ÌôïÏù∏
            checkDirectoryAndPermissions()

        } catch (ioe: IOException) {
            Log.e(TAG, "‚ùå Couldn't start file server: ${ioe.message}")
        }
    }

    fun stopServer() {
        stop()
        Log.d(TAG, "üõë File server stopped.")
    }
}